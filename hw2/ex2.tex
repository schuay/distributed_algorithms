\newcommand{\off}[1]{\text{off}_{#1}}
\newcommand{\rev}[1]{\text{rev}(#1)}

\begin{Exc}{(A3.9.v0, 4 points):}
Consider the ring $R_n^{rev}$, where processor $p_i$ has UID
$rev(i)$, $0\leq i \leq n-1$ for $n=2^k$. Prove that all
consecutive segments of size $2^\ell$, $0<\ell < k$, in $R_n^{rev}$
are order-equivalent.
\end{Exc}

\begin{lemma} \label{lemma:msb_order}
Let $x, y$ be $k$-bit integers with non-identical $\ell$ most significant bits
which we call $x_{MSB}, y_{MSB}$, respectively. Then the ordering relation of $x, y$ is
completely determined by $x_{MSB}, y_{MSB}$.
\end{lemma}

\begin{proof}
Let $i$ be the position of the highest differing bit between $x, y$, and let
its value be denoted $x_i, y_i$. Note that
$k - \ell \leq i < k$ since $x_{MSB}, y_{MSB}$ are non-identical. 
Without loss of generality, assume that $x_i = 0$ and $y_i = 1$.

We now construct $x', y'$ by copying the highest bits up to (and including) bit 
$i$ from $x, y$, and clearing all remaining bits. By the properties of binary 
arithmetic, $y' = x' + 2^i$ and therefore $x' < y'$.

Assume by way of contradiction that we can now use the lower bits $0, \ldots, i - 1$
to change the ordering relation. Construct $x''$ by copying the highest bits up
to (and including) bit $i$ from $x'$, and setting all remaining bits. However,
$x'' = x' + 2^i - 1 = y' - 1$ and therefore $x'' < y'$ still holds.
\end{proof}

\begin{theorem}
All consecutive segments of size $2^\ell$, $0<\ell < k$, in $R_n^{rev}$
are order-equivalent.
\end{theorem}

\begin{proof}
Take any index $0 \leq s < n$, any $0 < \ell < k$, and any $0 \leq \off{i}, \off{j} < 2^\ell$ (all
arithmetic in this proof is modulo $n$).
Let indices $i = s + \off{i}$, $j = s + \off{j}$, $i' = i + 2^\ell$, and $j' = j + 2^\ell$, i.e.
we consider the segment $S$ of length $2^\ell$ starting at $s$ and its neighbor segment $S'$ starting
at $s' = s + 2^\ell$. $i, j$ are arbitrary nodes within $S$, and $i', j'$ their corresponding nodes
in $S'$.

We now prove that $S, S'$ are order-equivalent by showing that
$\rev{i} < \rev{j} \iff \rev{i'} < \rev{j'}$.

Notice that 

\begin{enumerate}[a)]
\item adding $2^\ell$ to $i$ ($j$) does not affect the $\ell$ least significant
      bits of $i$ ($j$) since $i$ ($j$) is an $n$-bit integer and addition is modulo $2^n$,
      and that \label{item:a}
\item in any sequence of $2^\ell$ consecutive numbers, the $\ell$ least significant
      bits are unique. \label{item:b}
\end{enumerate}

It follows from \ref{item:a} that the $\ell$ least significant bits of $i'$ ($j'$) are identical to those of
$i$ ($j$). These in turn are the $\ell$ most significant bits in $\rev{i}, \rev{j}, \rev{i'}, \rev{j'}$,
and it follows from \ref{item:b} and Lemma \ref{lemma:msb_order} that they 
completely determine the ordering relation of all elements in segments $S, S'$.

Since $S, S'$ are arbitrary consecutive segments, order-equivalence holds for
any, and thus all consecutive segments.
\end{proof}


% ------------------------------------------------------------------------------

\begin{Exc}{(A3.10.1.v1, 5 points):}
Consider an anonymous ring where processors start with binary
inputs. Prove rigorously that there is no uniform synchronous
algorithm for computing the AND of all the input bits.
\end{Exc}

\begin{proof}
By way of contradiction, assume that there exists an anonymous, uniform,
synchronous algorithm that computes the logical AND over the input of
all processors such that each participating processor knows the result upon termination,
and fix any such algorithm $A$.
Assume that it terminates with result $1$ in $r(n)$ rounds when executed on a ring $R$ consisting
of $n$ processors $p_0, \ldots, p_{n-1}$ with all inputs equalling $1$.

We now construct a ring $R'$ by combining a segment of $n + 2r(n)$ processors with input $1$
($\underline{p}_i, p_i, \overline{p}_i$) with a single processor with input $0$ ($q$):
$R' = 
(\underline{p}_0, \ldots, \underline{p}_{r(n) - 1},
 p_0, \ldots, p_{n-1},
 \overline{p}_0, \ldots, \overline{p}_{r(n) - 1},
 q)$.

Consider the first $r(n)$ rounds of an execution of $A$ on the ring $R'$. Since by anonymity
the $r(n)$-neighborhood
of each $p_i$ in $R'$ is equivalent to the $r(n)$-neighborhood for each $p_i$ in $R$, their state
after $r(n)$ rounds must be identical (Lemma 130 from the lecture slides),
i.e. they must have terminated with result $1$. This is however
a contradiction, since input $0$ of node $q$ forces the output of the algorithm to $0$.
\end{proof}

% ------------------------------------------------------------------------------

\begin{Exc}{(A3.10.3.v3, 7 points):}
Consider an anonymous ring where processors start with binary
inputs. Prove that $\Omega(n^2)$ is a lower bound for the
message complexity of any (non-uniform, message-driven)
asynchronous algorithm that computes the AND of all the
input bits. Show by means of a counter-example that this
lower bound does not hold for synchronous algorithms.
\end{Exc}

We will show the lower bound of $\Omega(n^2)$ messages for an anonymous, non-uniform,
asynchronous algorithm calculating the logical AND over all binary inputs by
constructing a highly symmetrical ring $S_n = (p_0, \ldots, p_{n-2}, q)$ and showing
that any anonymous, non-uniform, synchronous algorithm $A$ which gains knowledge solely
through reception of messages (i.e. not through non-reception in a specific round)
must send at least $\Omega(n^2)$ messages.
We assume
that at the end of the algorithm, every processor must know the overall result.

The ring $S_n$ consists of a single processor $q$ with input 0 and an odd number of processors 
$P = \{ p_0, \ldots, p_{n-2} \}, |P| = n - 1$ with input 1. Note that since $A$ is anonymous, all $p_i$
have identical state machines. Furthermore, any processors $p_i$ with a $k$-neighborhood consisting solely
of $p_j \in P$ (a k-P-neighborhood) exhibit identical behavior in the first $k$ rounds
in which any such $p_i$ is active (Lemma 130 from the lecture slides).

\begin{lemma} \label{lemma:nrkpneighborhoods}
For $0 \leq k < \frac{n-1}{2}$, $S_n$ has exactly $n-2k-1$ k-P-neighborhoods.
\end{lemma}

\begin{proof}
A k-P-neighborhood consists of $2k + 1$ processors. For a fixed $k$, the first
k-P-neighborhood ranges from $p_0$ to $p_{2k}$ while the last ranges from $p_{n-2-2k}$
to $p_{n-2}$, with a k-P-neighborhood starting at every $p_i, 0 \leq i < n - 2k - 1$.
\end{proof}

Note that any $p_i$ at the center of a k-P-neighborhood communicates solely with
processors $\in P$ in the first $k$ active (definition as in the book and lecture)
rounds $r_0, \ldots, r_{k-1}$, and therefore cannot decide on a final result of $0$ within the first $k$
active rounds.

Since we require all processors to know the final result, this implies that the
algorithm cannot terminate in any active round $r_k, k < \frac{n-1}{2}$ because
(by Lemma \ref{lemma:nrkpneighborhoods}) for each such $r_k$ at least one k-P-neighborhood exists and we must have at least
$\frac{n-1}{2}$ rounds for $p_{\frac{n-1}{2}}$ to learn the result.

\begin{theorem} \label{theorem:and_lower_bound}
Any anonymous, non-uniform, asynchronous algorithm calculating the logical AND
must send $\Omega(n^2)$ messages.
\end{theorem}

\begin{proof}
The information from processor $q$ must reach $p_{\frac{n-1}{2}}$, and thus must 
pass either through all $p_0, \ldots, p_{\frac{n-1}{2}}$, or through all
$p_{\frac{n-1}{2}}, \ldots, p_{n-2}$. Therefore, all $p_i$ with k-P-neighborhoods
must transmit at least one message for all $k$, $0 \leq k < \frac{n-1}{2}$.

In each such round $r_k$, by Lemma \ref{lemma:nrkpneighborhoods}
there are $n-2k-1$ processors with identical k-P-neighborhoods, each of which
must send a message because the information from $q$ must reach the opposing processor
$p_{\frac{n-2}{2}}$. This results in a lower bound of:

\begin{align}
\sum_{k = 0}^{\frac{n-1}{2}} (n-2k-1) = \frac{(n-1)(n+1)}{4} = \Omega(n^2)
\end{align}

messages when executing $A$ on $S_n$. Since lock-step synchronous execution
is a special case of asynchronous execution, the lower bounds holds for
any asynchronous algorithm.
\end{proof}


\begin{theorem}
The lower bound of $\Omega(n^2)$ messages for an anonymous, non-uniform algorithm calculating the
logical AND of all binary inputs does not hold in synchronous systems.
\end{theorem}

\begin{proof}
The following algorithm $A$ for a ring of size $n$ with processors $p_0, \ldots, p_{n-1}$
is given as a counterexample. 
Initially, all $p_i$ with input $0$ send $msg_0$ to their
left neighbor.
In rounds $1, \ldots, n-1$, processors with input $1$ simply forward all received
messages, while $p_i$ with input $0$ swallow all messages. In round $n$,
each processor terminates with result ``false'' if it has received a message, and
result ``true'' otherwise.

This algorithm calculates the logical AND with $O(n)$ message complexity since
each $p_i$ sends at most one message.
\end{proof}

% ------------------------------------------------------------------------------

\begin{Exc}{(S2.3.v0, 10 points):}
Consider the simple asynchronous leader election algorithm of Sec.~3.3.1 of
the textbook (Slide 104 of the lecture slides). Provide the complete
pseudo-code description and the transition relation of this algorithm,
and a complete and rigorous correctness proof (safety and liveness).
\end{Exc}

\begin{algorithm}
\caption{Simple asynchronous leader election} \label{alg:ale}
\begin{algorithmic}[1]
\Statex Code for processor $p_i, 0 \leq i < n$
\Statex Initially, $leader_i = $ null, and $id_i$ has been sent to the left neighbor
\For{each received message}
    \If{$leader_i \neq $ null}
        \State \textbf{continue}
    \EndIf

    \If{received message $id_j > id_i$}
        \State forward $id_j$ to left neighbor
    \ElsIf{received message $id_j = id_i$}
        \State $leader_i \gets id_i$
        \State send termination message with $id_i$ to left neighbor
    \ElsIf{received message $id_j < id_i$}
        \State do nothing, i.e. swallow message
    \ElsIf{received termination message with $id_j$}
        \State $leader_i \gets id_j$
        \State send termination message with $id_j$ to left neighbor
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

In this example, $id_i$ denotes the processor ID of $p_i$ for all $i$, and all
index arithmetic is modulo $n$.
The transition relations are as follows:

Variables $\in L_i$ of processor $p_i$:
\begin{itemize}
\item $leader_i[\cdot]$: a node ID or null
\end{itemize}

Initial state for all $i$:
\begin{itemize}
\item $leader_i = null$
\item $\inbuf_i[\cdot] = \emptyset$
\item $\outbuf_i[left] = id_i$
\item $\outbuf_i[right] = \emptyset$
\end{itemize}

Elementary transitions for each $p_i$:
\begin{itemize}
\item $\forall q_i \in Q_i: id_j \in \inbuf_i[right]: id_j > id_i$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $\outbuf'_i[left] = \outbuf_i[left] \cup \{id_j\}$
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: id_j \in \inbuf_i[right]: id_j = id_i$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $leader'_i = id_j$
      \item $\outbuf'_i[left] = \outbuf_i[left] \cup \{term_i\}$
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: id_j \in \inbuf_i[right]: id_j < id_i$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: term_j \in \inbuf_i[right]$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $leader'_i = id_j$
      \item $\outbuf'_i[left] = \outbuf_i[left] \cup \{term_j\}$
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{term_j\}$
      \end{itemize}
\item For all other $q_i \in Q_i$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $\inbuf'_i[\cdot] = \emptyset$
      \end{itemize}
\end{itemize}

The set of compound transitions $\Phi'_i$ consists of the transitive closure over all elementary
transitions such that only a single compound transition is included for a given configuration.

Safety in the context of leader election algorithms means that at most one processor is in the
elected state at any time. This particular algorithm elects the processor with the maximal ID.
Let $p_0$ be that processor in ring $R = (p_0, \ldots, p_{n-1})$. Let $\outbuf_i$ be a shorthand for
$\outbuf_i[\text{left}]$.

\begin{theorem}
No processor other than $p_0$ can terminate as the leader.
\end{theorem}

\begin{proof}
Observe that in order to terminate as the leader, a processor $p_i$ must receive its own message
$id_i$, and that (since the message originated at $p_i$ itself and messages are sent only to the left)
this message must have traversed the entire ring. It follows from the code that the processor with
the maximal id $p_0$ will never forward a message $id_i < id_0$; therefore no $p_i, i \neq 0$ can
terminate as the leader.
\end{proof}

Liveness of a leader election algorithm implies that eventually all processors terminate, and
at least one processor enters an elected state.

\begin{lemma} \label{lemma:le-liveness}
The message containing $id_0$ is eventually sent by each processor $p_i$ to $p_{i+1}$,
$0 \leq i < n$.
\end{lemma}

\begin{proof}
By induction on the processor position $i$.

In the initial state, $p_0$ has sent $id_0$ to $p_1$.

Assume the statement holds
for processor $p_{i-1}$; then for $0 < i < n$:

Since the execution is admissible, $id_0$ is eventually
delivered and processed at $p_{i}$. Since $id_0$ is maximal over all IDs, processor IDs
are unique, and $i > 0$, it must be forwarded by $p_i$ and is therefore sent to $p_{i+1}$.
\end{proof}

\begin{theorem} \label{theorem:liveness1}
Processor $p_0$ eventually enters an elected state.
\end{theorem}

\begin{proof}
By lemma \ref{lemma:le-liveness}, $p_{n-1}$ eventually sends $id_0$ to $p_0$.
$p_0$ therefore receives its own id, sends a termination message to $p_1$,
and terminates as the leader.
\end{proof}

\begin{theorem}
Eventually all other processors $p_i, i > 0$ terminate.
\end{theorem}

\begin{proof}
By Theorem \ref{theorem:liveness1}, $p_0$ eventually enters the elected state,
upon which a termination message to $p_1$ is sent. Each remaining $p_i, i > 0$ terminates
as non-leader on receiving the termination message, and forwards it to the left neighbor.
By a similar induction proof as Lemma \ref{lemma:le-liveness}, the termination message
is eventually sent to all processors.
\end{proof}

\section{Review Feedback}

Thanks to both reviewers for their constructive comments.

\subsection{Review 1}.

This review caught the most major mistakes (leader election vs. AND, anonymity,
asynchronous algorithms don't have rounds), but missed some details in exercise
4's transition relations and pseudo-code. In general, it is somewhat lacking in detail;
for instance, it would be helpful to state why you found a certain section
confusing.

A part of exercise 1 was split into a separate lemma + proof. I also added a 
clarification about addition modulo $2^n$ in $n$-bit integers. I did not change
the proof in exercise 2 since I believe the structure is perfectly clear.

I don't agree that a proof is incomplete if intermediate steps in the sum
calculation are not included - these are very trivial to verify. The counterexample
has been corrected.

Again, I disagree that Theorem 3 would have required an induction proof. In any case,
much of this exercise (including Theorem 3) has been replaced by a corrected
version that does not rely on rounds.

Grade: 3-

\subsection{Review 2}.

A helpful review that caught most minor and major issues. I extracted a train of
thought in exercise 1 into Lemma 1, hopefully it should be clearer this way.

All changes proposed for exercise 2 were integrated.

In exercise 3, I initially
included all steps of the calculation in Theorem \ref{theorem:and_lower_bound},
but later removed interim steps since they can be reproduced using basic arithmetic
(basically, split the sum into 3 sums; the first and last sum are trivial, and
the middle sum can be solved with a simple sum formula). The counter-example
now gives an anonymous algorithm calculating the logical AND over all inputs.

All changes proposed for exercise 4 were integrated.

Grade: 1
