\newcommand{\off}[1]{\text{off}_{#1}}
\newcommand{\rev}[1]{\text{rev}(#1)}

\begin{Exc}{(A3.9.v0, 4 points):}
Consider the ring $R_n^{rev}$, where processor $p_i$ has UID
$rev(i)$, $0\leq i \leq n-1$ for $n=2^k$. Prove that all
consecutive segments of size $2^\ell$, $0<\ell < k$, in $R_n^{rev}$
are order-equivalent.
\end{Exc}

\begin{proof}
Take any index $0 \leq s < n$, any $0 < \ell < k$, and any $0 \leq \off{i}, \off{j} < 2^\ell$ (all
arithmetic in this proof is modulo $n$).
Let indices $i = s + \off{i}$, $j = s + \off{j}$, $i' = i + 2^\ell$, and $j' = j + 2^\ell$, i.e.
we consider the segment $S$ of length $2^\ell$ starting at $s$ and its neighbor segment $S'$ starting
at $s' = s + 2^\ell$. $i, j$ are arbitrary nodes within $S$, and $i', j'$ their corresponding nodes
in $S'$.

We now prove that $S, S'$ are order-equivalent by showing that
$\rev{i} < \rev{j} \iff \rev{i'} < \rev{j'}$.

Notice that a) adding $2^\ell$ to $i$ ($j$) does not affect the $\ell$ least significant bits of $i$ ($j$),
and that b) in any sequence of $2^\ell$ consecutive numbers, the $\ell$ least significant bits are unique.
It follows from a) that the $\ell$ least significant bits of $i'$ ($j'$) are identical to those of
$i$ ($j$). These in turn are the $\ell$ most significant bits in $\rev{i}, \rev{j}, \rev{i'}, \rev{j'}$,
and it follows from b) that they completely determine the ordering relation of all elements in segments
$S, S'$.
\end{proof}

% ------------------------------------------------------------------------------

\begin{Exc}{(A3.10.1.v1, 5 points):}
Consider an anonymous ring where processors start with binary
inputs. Prove rigorously that there is no uniform synchronous
algorithm for computing the AND of all the input bits.
\end{Exc}

\begin{proof}
By way of contradiction, assume that there exists an anonymous, uniform,
synchronous algorithm that computes the logical AND over the input of
all processors, and fix any such algorithm $A$.
Assume that it terminates with result $1$ in $r(n)$ rounds when executed on a ring $R$ consisting
of $n$ processors $p_0, \ldots, p_{n-1}$ with all inputs equalling $1$.

We now construct a ring $R'$ by combining a segment of $n + 2r(n)$ processors with input $1$
($\underline{p}_i, p_i, \overline{p}_i$) with a single processor with input $0$ ($q$):
$\underline{p}_0, \ldots, \underline{p}_{r(n) - 1},
 p_0, \ldots, p_{n-1},
 \overline{p}_0, \ldots, \overline{p}_{r(n) - 1},
 q.$
Consider the first $r(n)$ rounds of an execution of $A$ on the ring $R'$. Since by anonymity
the $r(n)$-neighborhood
of each $p_i$ in $R'$ is equivalent to the $r(n)$ neighborhood for each $p_i$ in $R$, their state
after $r(n)$ rounds must be identical, i.e. they must have terminated with result $1$. This is however
a contradiction, since input $0$ of node $q$ forces the output of the algorithm to $0$.
\end{proof}

% ------------------------------------------------------------------------------

\begin{Exc}{(A3.10.3.v3, 7 points):}
Consider an anonymous ring where processors start with binary
inputs. Prove that $\Omega(n^2)$ is a lower bound for the
message complexity of any (non-uniform, message-driven)
asynchronous algorithm that computes the AND of all the
input bits. Show by means of a counter-example that this
lower bound does not hold for synchronous algorithms.
\end{Exc}

We will show the lower bound of $\Omega(n^2)$ messages for an anonymous, non-uniform,
asynchronous algorithm calculating the logical AND over all binary inputs by
constructing a highly symmetrical ring $S_n = (p_0, \ldots, p_{n-2}, q)$ and showing
that any anonymous, non-uniform, symmetric algorithm $A$ which gains knowledge solely
through reception of messages (i.e. not through non-reception in a specific round)
must send at least $\Omega(n^2)$ messages.
We assume
that at the end of the algorithm, every processor must know the overall result.

The ring $S_n$ consists of a single processor $q$ with input 0 and an even number of processors 
$P = \{ p_0, \ldots, p_{n-2} \}, |P| = n - 1$ with input 1. Note that since $A$ is anonymous, all $p_i$
have identical state machines. Furthermore, any k-neighborhood consisting solely
of $p_i \in P$ (a k-P-neighborhood) exhibit identical behavior in the first $k$ active rounds.

\begin{lemma} \label{lemma:nrkpneighborhoods}
For $0 \leq k < \frac{n-1}{2}$, $S_n$ has exactly $n-2k-1$ k-P-neighborhoods.
\end{lemma}

\begin{proof}
A k-P-neighborhood consists of $2k + 1$ processors. For a fixed $k$, the first
k-P-neighborhood ranges from $p_0$ to $p_{2k}$ while the last ranges from $p_{n-2-2k}$
to $p_{n-2}$, with a k-P-neighborhood starting at every $p_i, 0 \leq i < n - 2k - 1$.
\end{proof}

Note that any $p_i$ at the center of a k-P-neighborhood communicates solely with
processors $\in P$ in the first $k$ active (definition as in the book and lecture)
rounds $r_0, \ldots, r_{k-1}$, and therefore cannot decide on a final result of $0$ within the first $k$
active rounds.

Since we require all processors to know the final result, this implies that the
algorithm cannot terminate in any active round $r_k, k < \frac{n-1}{2}$ because
in each such round at least one k-P-neighborhood exists.

% TODO: Change definition of 'active round' to 'P-active round', which only considers
%       messages sent by a processor in P.

\begin{theorem}
Any anonymous, non-uniform, asynchronous algorithm calculating the logical AND
must send $\Omega(n^2)$ messages.
\end{theorem}

\begin{proof}
We've seen that there are at least $\frac{n-1}{2}$ active rounds. In round $r_k$,
there are $n-2k-1$ processors with identical k-P-neighborhoods, each of which
send a message. This results in a lower bound of:

\begin{align}
\sum_{k = 0}^{\frac{n-1}{2}} (n-2k-1) = \frac{(n-1)(n+1)}{4} = \Omega(n^2)
\end{align}

messages when executing $A$ on $S_n$. Since lock-step synchronous execution
is a special case of asynchronous execution, the lower bounds holds for
any asynchronous algorithm.
\end{proof}


\begin{theorem}
The lower bound of $\Omega(n^2)$ messages for an anonymous, non-uniform algorithm calculating the
logical AND of all binary inputs does not hold in synchronous systems.
\end{theorem}

\begin{proof}
The following algorithm for a ring of size $n$ with processors $p_0, \ldots, p_{n-1}$
is given as a counterexample. Let the maximum over all processor ids be $p_{max}$.
The algorithm proceeds in $p_{max}$ phases of $n$ rounds each.
In the first round of phase $i$, if it has not terminated yet,
processor $p_i$ sends a leader message containing its id
to its left neighbor and terminates as the leader. Upon receiving a message, non-terminated processors
terminate as non-leaders and forward the message to their left neighbor. Since there
are $n$ rounds in phase $i$, the leader message can propagate to all nodes before
round $i+1$ begins.

This algorithm elects a leader with $O(n)$ message complexity (only the processor with the lowest
id gets to send its leader message, which is then forwarded exactly once by all other processors in
the ring).
\end{proof}

% ------------------------------------------------------------------------------

\begin{Exc}{(S2.3.v0, 10 points):}
Consider the simple asynchronous leader election algorithm of Sec.~3.3.1 of
the textbook (Slide 104 of the lecture slides). Provide the complete
pseudo-code description and the transition relation of this algorithm,
and a complete and rigorous correctness proof (safety and liveness).
\end{Exc}

\begin{algorithm}
\caption{Simple asynchronous leader election} \label{alg:ale}
\begin{algorithmic}[1]
\Statex Code for processor $p_i, 0 \leq i < n$
\Statex Initially, $leader_i = $ null, and $id_i$ has been sent to the left neighbor
\For{each round}
    \If{$leader_i \neq $ null}
        \State \textbf{continue}
    \EndIf

    \If{received message $id_j > id_i$}
        \State forward $id_j$ to left neighbor
    \ElsIf{received message $id_j = id_i$}
        \State $leader_i \gets id_i$
        \State send termination message with $id_i$ to left neighbor
    \ElsIf{received message $id_j < id_i$}
        \State do nothing, i.e. swallow message
    \ElsIf{received termination message with $id_j$}
        \State $leader_i \gets id_j$
        \State send termination message with $id_j$ to left neighbor
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

The transition relations are as follows:

Variables $\in L_i$ of processor $p_i$:
\begin{itemize}
\item $leader_i[\cdot]$: a node ID or null
\end{itemize}

Initial state for all $i$:
\begin{itemize}
\item $leader_i = null$
\item $\inbuf_i[\cdot] = \emptyset$
\item $\outbuf_i[left] = id_i$
\item $\outbuf_i[right] = \emptyset$
\end{itemize}

Elementary transitions for each $p_i$:
\begin{itemize}
\item $\forall q_i \in Q_i: id_j \in \inbuf_i[right]: id_j > id_i$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $\outbuf'_i[left] = \outbuf_i[left] \cup \{id_j\}$
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: id_j \in \inbuf_i[right]: id_j = id_i$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $leader'_i = id_j$
      \item $\outbuf'_i[left] = \outbuf_i[left] \cup \{term_i\}$
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: id_j \in \inbuf_i[right]: id_j < id_i$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: term_j \in \inbuf_i[right]$ and $leader_i = null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $leader'_i = id_j$
      \item $\inbuf'_i[right] = \inbuf_i[right] \setminus \{id_j\}$
      \end{itemize}
\item $\forall q_i \in Q_i: leader_i \neq null$.
      Then $(q_i, \phi_i, q'_i) \in \Phi_i$,
      where $q'_i = q_i$ except:
      \begin{itemize}
      \item $\inbuf'_i[\cdot] = \emptyset$
      \end{itemize}
\end{itemize}

The set of compound transitions $\Phi'_i$ consists of the transitive closure over all elementary
transitions such that only a single compound transition is included for a given configuration. An
idle transition is included as well.

Safety in the context of leader election algorithms means that at most one processor is in the
elected state at any time. This particular algorithm elects the processor with the maximal ID.
Let $p_0$ be that processor in ring $R = (p_0, \ldots, p_{n-1})$. Let $\outbuf_i$ be a shorthand for
$\outbuf_i[\text{left}]$, and $id_i$ for $id(p_i)$.

\begin{theorem}
No processor other than $p_0$ can terminate as the leader.
\end{theorem}

\begin{proof}
Observe that in order to terminate as the leader, a processor $p_i$ must receive its own message
$id_i$, and that (since the message originated at $p_i$ itself and messages are sent only to the left)
this message must have traversed the entire ring. It follows from the code that the processor with
the maximal id $p_0$ will never forward a message $id_i < id_0$; therefore no $p_i, i \neq 0$ can
terminate as the leader.
\end{proof}

Liveness of a leader election algorithm implies that eventually all processors terminate, and
at least one processor enters an elected state.

\begin{lemma} \label{lemma:le-liveness}
The message containing $id_0$ is in $\outbuf_{r-1}$ at the beginning of round $r \leq n$.
\end{lemma}

\begin{proof}
By induction on the round number $r$.

In the initial state and therefore at the beginning of round $0$, $id_0$ is in $\outbuf_0$.

Assume the statement holds
in round $r$; since $id_0$ is then in $\outbuf_{r-1}$ at the beginning of the round, it is received
by $p_r$ in the same round. Since $id_0$ is maximal over all IDs, it must be forwarded by $p_r$
and is therefore placed into $\outbuf_r$ at the beginning of round $r + 1$.
\end{proof}

\begin{theorem}
Processor $p_0$ enters an elected state in round $n$, and all other processors terminate
by round $2n$.
\end{theorem}

\begin{proof}
By lemma \ref{lemma:le-liveness}, $id_0$ is in $\outbuf_{n-1}$ at the beginning of round $n$.
$p_0$ therefore receives its own id in the same round, sends a termination message to $p_1$,
and terminates as the leader. Upon receiving the termination message, every non-terminated
processor $p_i$ 1) forwards the message (proof by induction) and 2) terminate. Since there are
$n$ processors, $n$ additional rounds are needed for the termination message to propagate completely.
\end{proof}

